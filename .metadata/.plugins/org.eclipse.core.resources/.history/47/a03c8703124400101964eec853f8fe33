package com.example.patientservice.security;

import com.example.patientservice.security.jwt.JwtAuthEntryPoint;
import com.example.patientservice.security.jwt.JwtAuthFilter;

import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

// Đánh dấu lớp này là lớp cấu hình
@Configuration
// Kích hoạt tính năng bảo mật web của Spring boot
@EnableWebSecurity
public class SecurityConfig {
	// Inject JwtAuthFilter
	@Autowired
	private JwtAuthFilter jwtAuthFilter;
	
	// Inject JwtAuthEntryPoint để xử lý lỗi xác thực
	@Autowired
	private JwtAuthEntryPoint unauthorizedHandler;
	
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    	http
        // Tắt CSRF (Cross-Site Request Forgery) vì nó không cần thiết cho REST API không dùng session
        .csrf(csrf -> csrf.disable())
        // Cấu hình xử lý ngoại lệ: khi có lỗi xác thực, sử dụng unauthorizedHandler
        .exceptionHandling(exception -> exception.authenticationEntryPoint(unauthorizedHandler))
        // Cấu hình quản lý session: đặt chính sách là STATELESS vì chúng ta dùng JWT (không lưu trạng thái session)
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        // Cấu hình quy tắc ủy quyền cho các yêu cầu HTTP
        .authorizeHttpRequests(auth -> auth
            // Cho phép endpoint tạo patient (POST /api/patients) mà không cần xác thực JWT.
            // Điều này phù hợp nếu User Service gọi nội bộ để tạo patient sau khi đăng ký user.
            // Nếu endpoint này được gọi trực tiếp từ client, bạn CẦN THÊM bảo mật cho nó.
            .requestMatchers("/api/patients").permitAll() // Ví dụ: POST /api/patients

            // Yêu cầu xác thực (authenticated) cho TẤT CẢ CÁC ENDPOINT CÒN LẠI bắt đầu bằng /api/patients/
            // Điều này bao gồm GET /api/patients/user/{userId}, GET /api/patients/{patientId}, PUT, DELETE, v.v.
            .requestMatchers("/api/patients/**").authenticated() 
            
            // Mặc định, bất kỳ request nào khác không được định nghĩa cụ thể ở trên cũng yêu cầu xác thực
            .anyRequest().authenticated() 
        );

	    // Thêm JwtAuthFilter vào chuỗi bộ lọc của Spring Security.
	    // Nó sẽ được chạy TRƯỚC UsernamePasswordAuthenticationFilter (bộ lọc xác thực username/password mặc định của Spring),
	    // đảm bảo JWT của chúng ta được xử lý đầu tiên.
    	http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

    	return http.build();
    }
}